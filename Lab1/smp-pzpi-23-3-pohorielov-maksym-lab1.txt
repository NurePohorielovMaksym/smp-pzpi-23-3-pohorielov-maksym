МІНІСТЕРСТВО НАУКИ І ОСВІТИ УКРАЇНИ


ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ










Кафедра «Програмна інженерія»








ЗВІТ
з лабораторної роботи №1
з дисципліни «Скриптові мови програмування»
на тему: «Bash-скрипт для перетворення CSV файла»












 
Виконав:                                                                         Прийняв:
ст. гр. ПЗПІ-23-3                                                            ст. викладач кафедри ПІ
Погорєлов М. І.                                                              Сокорчук Ігор Петрович


















Харків 2025
1 ІСТОРІЯ ЗМІН


№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	21.03.2025
	0.1
	Створено розділ «Завдання»
	2
	22.03.2025
	0.1
	Створено розділ «Опис Виконаної роботи»
	3
	23.03.2025
	0.1
	Створено розділ «Висновки»
	4
	23.03.2025
	0.1
	Створено розділ «Додаток А»
	5
	23.03.2025
	0.1
	Створено розділ «Додаток Б»
	6
	23.03.2025
	0.1
	Створено розділ «Додаток В»
	
















































2 ЗАВДАННЯ
Завдання лабораторної роботи полягає у створенні Bash-скрипта, який автоматично обробляє розклад занять, експортований із сайту https://cist.nure.ua у форматі CSV, і перетворює його у формат, придатний для імпорту в Google Календар. Скрипт повинен вміти зчитувати дані з вхідного файлу, обирати необхідну академічну групу, обробляти інформацію про заняття, формувати правильну структуру файлу відповідно до вимог Google, а також підтримувати кілька ключів командного рядка: --help, --version, -q або --quiet.
У разі, якщо користувач не вказав жодного параметра при запуску скрипта, запускається інтерактивний режим, у якому за допомогою команди select формується список CSV-файлів із розкладом у поточній директорії. Після вибору файлу користувачу пропонується обрати академічну групу зі списку, що генерується автоматично на основі даних у файлі. Дані фільтруються за назвою групи, і для кожного заняття визначається порядковий номер (лабораторні заняття рахуються як дві пари, інші – як одна).
Далі скрипт формує нові поля для експорту: «Subject» створюється з назви теми без префіксу групи, і доповнюється номером заняття; поля дати та часу перетворюються у 12-годинний формат із AM/PM згідно з вимогами Google Календаря; поле «Description» заповнюється з опису заняття. У підсумку формується CSV-файл з полями: Subject, Start date, Start time, End date, End time, Description.
Результат скрипта — це новий файл у форматі Google_TimeTable_??_??_20??.csv, який містить усі правильно відформатовані дані та готовий для завантаження до Google Календаря. Скрипт також повинен виводити результати у консоль, якщо не активовано тихий режим, та коректно обробляти можливі помилки: відсутність файлу, відсутність вказаної групи, помилки читання тощо.














3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Опис інженерних рішень
Для виконання завдання розроблено Bash-скрипт, який обробляє CSV-файли з розкладом занять та генерує файл у форматі, сумісному з Google Calendar, автоматизуючи обробку даних, вибір академічної групи та файлу, а також враховуючи специфіку структури розкладу (типи занять, їх тривалість). Використані технології та інструменти включають Bash для логіки обробки аргументів і управління файлами, awk для парсингу CSV, визначення типу занять і формування вихідного файлу, iconv для конвертації кодування з Windows-1251 у UTF-8, sed для очищення даних від BOM, лапок і зайвих пробілів, sort та grep для сортування й фільтрації груп, select для інтерактивного меню вибору файлу чи групи, а також роботу з файловою системою для читання вхідного CSV та створення вихідних файлів (Google_TimeTable_*.csv, Google_TimeTable_*_errors.txt). 
Скрипт структуровано модульно, з обробкою помилок (перевірка наявності файлів, валідності формату дати й часу, логування помилок), гнучким вибором файлу/групи (автоматичний для єдиних варіантів або інтерактивний через меню), автоматичним визначенням типу заняття (лекція, практика, лабораторна) за ключовими словами з тривалістю (2 години для лабораторних, 1 для інших), сортуванням даних за датою і часом, нумерацією занять для уникнення дублювання, обробкою кодування, видаленням BOM, перевіркою формату даних, резервною датою з назви файлу та формуванням CSV із полями Google Calendar (Subject, Start Date, Start Time, End Date, End Time, Description), враховуючи парність лабораторних занять.


3.2 Розробка скрипта 
3.2.1 Ініціалізація змінних
Скрипт починається з визначення глобальних змінних:
* VERSION="1.0": Версія скрипта, використовується для виведення інформації про програму.
* QUIET=0: Прапорець для керування виведенням повідомлень (0 — повне виведення, 1 — тихий режим).
3 VERSION="1.0"
4 QUIET=0
Фрагмент коду з основного сценарію, Додаток В.
3.2.2 Функції для виведення довідки та версії
Скрипт містить дві функції для надання інформації користувачу:
* show_help: Виводить синтаксис використання скрипта та доступні опції (--help, --version, -q/--quiet) разом із можливими аргументами (назва групи, шлях до CSV-файлу). Завершує виконання з кодом 0.
* show_version: Виводить версію скрипта (task2 версія 1.0) та завершує виконання з кодом 0.
Код функцій:
6 show_help() {
7   echo "Синтаксис:"
8   echo "  task2 [--help | --version]"
9   echo "  task2 [-q|--quiet] [академ_група] [файл.csv]"
10 }
11 show_version() {
12   echo "task2 версія $VERSION"
13 }
Фрагмент коду з основного сценарію, Додаток В.
3.2.3 Обробка аргументів командного рядка
Скрипт обробляє аргументи командного рядка за допомогою циклу while та конструкції case. Підтримуються наступні опції:
* --help: Викликає функцію show_help та завершує виконання.
* --version: Викликає функцію show_version та завершує виконання.
* -q|--quiet: Встановлює QUIET=1 для приглушення інформаційних повідомлень.
* Некоректні опції викликають повідомлення про помилку та завершення з кодом 1.
Змінні group_input та csv_path отримують значення з аргументів командного рядка для вказання академічної групи та шляху до CSV-файлу.


16 while [[ "$1" =~ ^- ]]; do
17   case "$1" in
18     --help) show_help; exit 0 ;;
19     --version) show_version; exit 0 ;;
20     -q|--quiet) QUIET=1; shift ;;
21     *) echo "Невідома опція: $1" >&2; exit 1 ;;
22   esac
23 done
24 
25 group_input="$1"
26 csv_path="$2"
Фрагмент коду з основного сценарію, Додаток В.
3.2.4. Вибір CSV-файлу
Якщо шлях до файлу (csv_path) не вказано, скрипт:
* Шукає файли за шаблоном TimeTable_??_??_20??.csv у поточній директорії.
* Якщо файли не знайдено, видає повідомлення про помилку та завершує виконання з кодом 1.
* Якщо файли є, пропонує користувачу вибрати один із них через інтерактивне меню select.
* Перевіряє, чи обраний файл існує та доступний для читання. У разі помилки завершує виконання з кодом 1.
28 if [[ -z "$csv_path" ]]; then
29   files=($(ls TimeTable_??_??_20??.csv 2>/dev/null | sort))
30   if [[ ${#files[@]} -eq 0 ]]; then
31   echo "Не знайдено CSV файлів за шаблоном TimeTable_??_??_20??.csv" >&2
32     exit 1
33   fi
34   echo "Оберіть файл:"
35   PS3="Введіть номер файлу: "
36   select csv_path in "${files[@]}"; do
37    [[ -n "$csv_path" ]] && break
38     echo "Неправильний вибір, спробуйте ще." >&2
39   done
40 fi
41 
42 if [[ ! -f "$csv_path" || ! -r "$csv_path" ]]; then
43   echo "Файл '$csv_path' не існує або недоступний для читання." >&2
44   exit 1
45 fi
Фрагмент коду з основного сценарію, Додаток В.
3.2.5 Вибір академічної групи
Скрипт витягує унікальні назви академічних груп із CSV-файлу:
* Використовує iconv для конвертації кодування з Windows-1251 у UTF-8.
* За допомогою sed видаляє BOM, лапки та нормалізує переноси рядків.
* Використовує awk для виділення назв груп із першого стовпця (формат: "група - тема").
* Сортує унікальні назви груп за допомогою sort -Vu.
Якщо групи не знайдено, скрипт видає помилку та завершує виконання. Якщо група не вказана:
* Для однієї доступної групи автоматично обирає її.
* Для кількох груп пропонує інтерактивний вибір через select.
* Якщо група вказана, перевіряє її наявність у списку доступних груп. У разі відсутності видає список доступних груп і завершує виконання з кодом 1.
47 available_groups=$(iconv -f windows-1251 -t utf-8 "$csv_path" | \
48  sed 's/\r\n/\n/g; s/\r/\n/g; s/^\xEF\xBB\xBF//' | \
49  sed 's/"//g' | \
50  awk -F',' 'NR > 1 && $1 ~ / - / { split($1, x, " - "); gsub(/^ +| +$/, "", x[1]); if (x[1] != "") print x[1] }' | sort -Vu)
51
52 if [[ -z "$available_groups" ]]; then
53  echo "У файлі '$csv_path' не знайдено жодної академічної групи." >&2
54  exit 1
55 fi
56
57 group_count=$(echo "$available_groups" | wc -l)
58 if [[ -z "$group_input"АКТ
59 group_count -eq 1 ]]; then
60   selected_group="$available_groups"
61 elif [[ -z "$group_input" ]]; then
62  PS3="Оберіть групу: "
63  select selected_group in $available_groups; do
64    [[ -n "$selected_group" ]] && break
65    echo "Неправильний вибір, спробуйте ще." >&2
66  done
67 else
68   selected_group="$group_input"
69   if ! echo "$available_groups" | grep -Fx "$selected_group" >/dev/null; 70 then
71     echo "Група '$selected_group' не знайдена у файлі '$csv_path'." >&2
72     echo "Доступні групи:" >&2
73     echo "$available_groups" >&2
74     exit 1
75   fi
76 fi
Фрагмент коду з основного сценарію, Додаток В.
3.2.6 Ініціалізація вихідних файлів
Скрипт створює:
* Вихідний файл Google_TimeTable_${date_part}.csv, де date_part витягується з назви вхідного файлу (формат: DD_MM_YYYY).
* Файл для логування помилок Google_TimeTable_${date_part}_errors.txt.
* Резервну дату (default_date), яка використовується, якщо дата в записі некоректна. За замовчуванням — 06/02/2025.
Вихідний файл ініціалізується з заголовком, сумісним із Google Calendar: "Subject","Start Date","Start Time","End Date","End Time","Description".


76 date_part=$(basename "$csv_path" .csv | sed -n  's/TimeTable_\(.*\)/\1/p')
77 result_file="Google_TimeTable_${date_part}.csv"
78 error_file="Google_TimeTable_${date_part}_errors.txt"


80 file_date=$(echo "$date_part" | sed 's/\([0-9]\{2\}\)_\([0-9]\{2\}\)_\([0-9]\{4\}\)/\2\/\1\/\3/')
81 default_date=${file_date:-"06/02/2025"}


83 echo "\"Subject\",\"Start Date\",\"Start Time\",\"End Date\",\"End Time\",\"Description\"" > "$result_file"
84 > "$error_file"
Фрагмент коду з основного сценарію, Додаток В.
3.2.7 Попередня обробка даних
На цьому етапі формується вхідний CSV-файл до обробки в awk, виконуючи конвертацію кодування та очищення даних.
* iconv -f windows-1251 -t utf-8 "$csv_path":
* Конвертує кодування вхідного файлу з Windows-1251 (поширене для кириличних текстів) у UTF-8, щоб забезпечити коректну обробку символів.
* sed 's/\r\n/\n/g; s/\r/\n/g; s/^\xEF\xBB\xBF//':
* Замінює Windows-символи переносу рядка (\r\n) на Unix-формат (\n).
* Видаляє окремі символи повернення каретки (\r).
* Видаляє BOM (Byte Order Mark, \xEF\xBB\xBF), який може бути присутнім у файлах UTF-8.
* sed 's/"//g': Видаляє всі подвійні лапки (") з даних, щоб спростити обробку в awk.
94 iconv -f windows-1251 -t utf-8 "$csv_path" | \
95   sed 's/\r\n/\n/g; s/\r/\n/g; s/^\xEF\xBB\xBF//' | \
96   sed 's/"//g' | \
Фрагмент коду з основного сценарію, Додаток В.
3.2.8 Ініціалізація та функція trim
Параметри awk:
* -F ',': Встановлює роздільник полів як кому.
* -v group="$selected_group": Передає вибрану групу в awk.
* -v default_date="$default_date": Передає резервну дату.
* -v OFS=',': Встановлює вихідний роздільник як кому.
Функція trim:
* Видаляє пробіли на початку (^ +) та в кінці ( +$) рядка.
* Використовується для очищення текстових даних (назви предметів, тем).
* Блок BEGIN:
* Встановлює PROCINFO["sorted_in"] = "@ind_str_asc" для сортування масивів у алфавітному порядку за ключами.
 97 awk -F ',' -v group="$selected_group" -v  default_date="$default_date" -v OFS=',' '
 98 function trim(s) {
 99  sub(/^ +/, "", s)
100  sub(/ +$/, "", s)
101  return s
102 }
103 BEGIN {
104  PROCINFO["sorted_in"] = "@ind_str_asc"
105 }
Фрагмент коду з основного сценарію, Додаток В.
3.2.9 Пошук поля з датою
Визначиння індексу поля, яке містить дату у форматі DD.MM.YYYY:
* Пропускає перший рядок (NR > 1), оскільки він є заголовком CSV.
* Ініціалізує змінну date_field_idx значенням 0.
* Перевіряє поля, починаючи з другого (i = 2), на відповідність регулярному виразу ^[0-3][0-9]\.[0-1][0-9]\.[0-9]{4}$ (формат дати DD.MM.YYYY, наприклад, 25.03.2025).
* Якщо поле з датою знайдено, зберігає його індекс у date_field_idx і припиняє цикл (break).
* Якщо поле з датою не знайдено (date_field_idx == 0), пропускає рядок (next).
Починається пошук із другого поля, оскільки перше поле зазвичай містить назву предмета та групу. Використовує регулярний вираз для точної перевірки формату дати, що забезпечує стійкість до некоректних даних.
106 NR > 1 {
107   date_field_idx = 0
108   for (i = 2; i <= NF; i++) {
109     if ($i ~ /^[0-3][0-9]\.[0-1][0-9]\.[0-9]{4}$/) {
110      date_field_idx = i
111      break
112    }
113  }
114  if (date_field_idx == 0) next
Фрагмент коду з основного сценарію, Додаток В.
3.2.10 Формування та фільтрація предмета
Отримати та очистити назву предмета, перевірити наявність вибраної групи та отримати тему заняття:
* Формує змінну subj, починаючи з першого поля ($1).
* Додає всі поля до date_field_idx (виключаючи поле з датою), об’єднуючи їх комами.
* Очищає subj від пробілів на початку та в кінці за допомогою функції trim.
* Перевіряє, чи містить subj вибрану групу та дефіс (group " - "). Якщо ні, пропускає рядок.
* Розділяє subj на масив a за шаблоном group " - ", щоб відокремити назву групи від теми.
* Якщо розбиття не дало принаймні двох частин (група та тема), пропускає рядок.
* Витягує тему (topic) з другої частини масиву a і очищає її через trim.
* Якщо тема порожня, пропускає рядок.
* Використання trim для видалення зайвих пробілів забезпечує чистоту даних.
* Перевірка на наявність дефіса та групи фільтрує нерелевантні рядки.
* Перевірка довжини масиву a і порожньої теми захищає від некоректних записів.
116 subj = $1
117   for (j = 2; j < date_field_idx; j++) {
118    subj = subj "," $j
119  }
120  subj = trim(subj)
121
122  if (subj !~ group " - ") next
123  split(subj, a, group " - ")
124  if (length(a) < 2) next
125  topic = trim(a[2])
126  if (topic == "") next
Фрагмент коду з основного сценарію, Додаток В.
3.2.11  Перевірка та форматування дати й часу
Перевіряє наявність і валідність полів дати та часу, відформатувати дату для Google Calendar:
* Перевіряє, чи достатньо полів у рядку для наявності дати та часу (NF < date_field_idx + 2). Якщо ні, пропускає рядок.
* Витягує дату (date) та час (time) із відповідних полів.
* Перевіряє валідність дати та часу:
* Якщо дата не відповідає формату DD.MM.YYYY, але час валідний (HH:MM), використовує резервну дату (default_date).
* Якщо дата або час не відповідають форматам, пропускає рядок.
* Розбиває дату на день, місяць і рік, видаляючи провідні нулі (наприклад, 05 → 5).
* Форматує дату у формат Google Calendar (MM/DD/YYYY, наприклад, 03/25/2025).
* Використання резервної дати забезпечує обробку некоректних записів із валідним часом.
* Суворі регулярні вирази для перевірки формату дати та часу.
* Форматування через split гарантує правильний формат із двозначними місяцем і днем.
 128  if (NF < date_field_idx + 2) next
 129  date = $(date_field_idx)
 130  time = $(date_field_idx + 1)


131  if (date !~ /^[0-3][0-9]\.[0-1][0-9]\.[0-9]{4}$/ && time ~ /^[0-2][0-9]:[0-5][0-9]/) {
132     date = default_date
133   } else if (date !~ /^[0-3][0-9]\.[0-1][0-9]\.[0-9]{4}$/ || time !~ /^[0-2][0-9]:[0-5][0-9]/) {
134     next
135   }
136   split(date, d, ".")
137   day = d[1] + 0
138   m = d[2] + 0
139   y = d[3] + 0
140   date_out = sprintf("%02d/%02d/%04d", m, day, y)
Фрагмент коду з основного сценарію, Додаток В.
3.2.12 Визначення типу заняття, форматування часу та збереження даних
Визначити тип заняття, відформатувати час у 12-годинний формат і зберегти дані для сортування:
* Переводить тему в нижній регістр (topic_lc) для пошуку ключових слів.
* Визначає тип заняття та тривалість:
* Лабораторні (лаб, лб): class_type = "lab", тривалість 2 години.
* Практичні (пз, прпа): class_type = "prac", тривалість 1 година.
* Лекції (лек, лекц або інші): class_type = "lec", тривалість 1 година.
* Видаляє номери типу №N із теми.
* Створює ключ base_key у форматі topic|class_type для подальшої нумерації.
* Розбиває час на години (sh) та хвилини (sm).
* Форматує час початку (stime) та закінчення (etime) у 12-годинний формат із AM/PM (наприклад, 14:30 → 02:30 PM).
* Створює ключ сортування (sort_key) у форматі YYYYMMDD_HHMM_NR для впорядкування подій.
* Зберігає дані у масив result у форматі base_key|"topic","date_out","stime","date_out","etime","subj".
* Використання нижнього регістру для надійного пошуку ключових слів.
* Автоматичне присвоєння типу "lec" для невідомих занять як значення за замовчуванням.
* Форматування часу через sprintf для відповідності вимогам Google Calendar.
* Унікальний ключ сортування включає номер рядка (NR), щоб уникнути конфліктів при однакових датах і часах.
145  topic_lc = tolower(topic)
146  if (topic_lc ~ /лаб|лб/) {
147    class_type = "lab"
148    duration = 2
149  } else if (topic_lc ~ /пз|прпа/) {
150    class_type = "prac"
151    duration = 1
152  } else if (topic_lc ~ /лек|лекц/) {
153    class_type = "lec"
154    duration = 1
155  } else {
156    class_type = "lec"
157    duration = 1
158  }
159  gsub(/;? *№[0-9]+/, "", topic)
160  base_key = topic "|" class_type
161   split(time, t, ":")
162  sh = t[1] + 0
163   sm = t[2]
164  ampm = (sh >= 12) ? "PM" : "AM"
165  sh12 = (sh % 12 == 0) ? 12 : sh % 12
166  stime = sprintf("%02d:%02d %s", sh12, sm, ampm)
167  eh = sh + duration
168  eampm = (eh >= 12) ? "PM" : "AM"
169  eh12 = (eh % 12 == 0) ? 12 : eh % 12
170  etime = sprintf("%02d:%02d %s", eh12, sm, eampm)
171  sort_key = sprintf("%04d%02d%02d_%02d%02d_%d", y, m, day, sh, sm, NR)
172  result[sort_key] = base_key "|" "\"" topic "\",\"" date_out "\",\"" stime "\",\"" date_out "\",\"" etime "\",\"" subj "\""
Фрагмент коду з основного сценарію, Додаток В.
3.2.13 Сортування подій
 Підготувати ключі подій для сортування.
* Ініціалізує лічильник n для підрахунку кількості подій.
* Перебирає ключі масиву result, зберігаючи їх у масив keys.
* Сортує ключі в масиві keys за допомогою asort у порядку зростання (задано в BEGIN як @ind_str_asc).
* Використання окремого масиву keys для сортування дозволяє зберегти порядок подій за датою, часом і номером рядка.
* Сортування через asort забезпечує коректне впорядкування подій у хронологічному порядку.
181 END {
182   n = 0
183   for (k in result) {
184     n++
185  asc
186    keys[n] = k
187   }
188  asort(keys)
Фрагмент коду з основного сценарію, Додаток В.
3.2.14  Нумерація занять і виведення результату
 Номерує заняття, враховуючи парність лабораторних, і вивести відформатовані дані:
* Перебирає відсортовані ключі (keys) і витягує відповідний рядок із result.
* Розбиває рядок на частини за символом |, витягує base_key (тема + тип заняття), class_type і решту даних (data).
* Ініціалізує лічильник (count_map) і стан парності (lab_pair_state) для кожної нової теми.
* Для лабораторних занять (class_type == "lab"):
* Якщо lab_pair_state == 1, використовує поточний номер (lesson_num) і встановлює стан 2 (друга частина пари).
* Інакше збільшує count_map, присвоює новий номер і встановлює стан 1 (перша частина пари).
* Для нелабораторних занять:
* Збільшує count_map, присвоює новий номер і скидає lab_pair_state на 0.
* Витягує тему (topic_text) з даних, видаляє старі номери (№N), додає новий номер (№lesson_num).
* Формує оновлений рядок (updated_data), замінюючи стару тему на нову з номером.
* Виводить відформатований рядок у вихідний файл.
* Використання lab_pair_state для відстеження парності лабораторних занять забезпечує коректну нумерацію (дві лабораторні події отримують однаковий номер).
* Регулярний вираз ^"[^"]+" точно витягує тему з даних.
* Оновлення лише теми в кінцевому рядку через sub зберігає решту полів без змін
189  for (i = 1; i <= n; i++) {
190    k = keys[i]
191    line = result[k]
192    split(line, parts, "|")
193    base_key = parts[1]
194    class_type = parts[2]
195    data = substr(line, length(base_key) + length(class_type) + 3)
196    if (!(base_key in count_map)) {
197      count_map[base_key] = 0
198      lab_pair_state[base_key] = 0
199    }
200    if (class_type == "lab") {
201      if (lab_pair_state[base_key] == 1) {
202        lesson_num = count_map[base_key]
203        lab_pair_state[base_key] = 2
204      } else {
205        count_map[base_key]++
206        lesson_num = count_map[base_key]
207        lab_pair_state[base_key] = 1
208      }
209    } else {
210      count_map[base_key]++
211      lesson_num = count_map[base_key]
212      lab_pair_state[base_key] = 0
213    }
214    match(data, /^"[^"]+"/)
215    topic_text = substr(data, RSTART + 1, RLENGTH - 2)
216    gsub(/;? *№[0-9]+/, "", topic_text)
217    new_topic = topic_text " №" lesson_num
218    updated_data = "\"" new_topic "\"" substr(data, RSTART + RLENGTH)
219    sub(/, *"[^"]+"$/, ",\"" new_topic "\"", updated_data)
220    print updated_data
221  }
222 }
Фрагмент коду з основного сценарію, Додаток В.
3.2.15  Перевірка успішності виконання awk
Перевірити, чи команда awk (попередня обробка CSV) завершилася успішно.
* Перевіряє код повернення попередньої команди ($?). Якщо він не дорівнює 0 (тобто сталася помилка), виконуються наступні дії:
* Виводить повідомлення про помилку обробки файлу $csv_path у потік помилок (>&2).
* Повідомляє, що деталі помилок записано у файл $error_file (хоча в цьому випадку деталі не записуються, оскільки помилка стосується виконання awk).
* Завершує виконання скрипта з кодом 1 (помилка).
* * Використання $? для перевірки статусу виконання попередньої команди забезпечує надійне виявлення помилок у конвеєрі обробки (iconv, sed, awk).
* Виведення повідомлень у stderr (>&2) відповідає стандартам Unix для логування помилок.
* Передчасне завершення скрипта (exit 1) запобігає подальшій обробці у разі критичної помилки.
230 if [[ $? -ne 0 ]]; then
231   echo "Помилка під час обробки файлу '$csv_path'." >&2
232   echo "Деталі помилок записано у '$error_file'." >&2
233   exit 1
234 fi
Фрагмент коду з основного сценарію, Додаток В.
3.2.16 Перевірка результату обробки
Перевірити, чи містить вихідний файл ($result_file) дані про заняття для вибраної групи.
* Перевіряє два умови:
* ! -s "$result_file": Файл порожній (немає даних).
* $(wc -l < "$result_file") -eq 1: Файл містить лише один рядок (заголовок, створений раніше).
* Якщо хоча б одна з умов виконується (тобто немає даних про заняття), виконуються дії:
* Записує повідомлення про відсутність занять для групи $selected_group у файлі $csv_path у файл помилок ($error_file).
* Виводить те саме повідомлення у потік помилок (>&2).
* Видаляє вихідний файл (rm -f "$result_file") для уникнення залишення порожнього або непотрібного файлу.
* Завершує виконання скрипта з кодом 1.
* Використання ! -s перевіряє розмір файлу, що ефективно виявляє порожні файли.
* Команда wc -l точно визначає кількість рядків, щоб відрізнити файл із лише заголовком від файлу з даними.
* Видалення файлу через rm -f (з прапорцем -f для примусового видалення без запитів) забезпечує чистоту файлової системи.
* Логування в $error_file і stderr забезпечує інформативність для користувача.
236 if [[ ! -s "$result_file" || $(wc -l < "$result_file") -eq 1 ]]; then
237  echo "Не знайдено занять для групи '$selected_group' у файлі '$csv_path'." >> "$error_file"
238  echo "Не знайдено занять для групи '$selected_group' у файлі '$csv_path'." >&2
239  rm -f "$result_file"
240  exit 1
241 fi
Фрагмент коду з основного сценарію, Додаток В.
3.2.17 Виведення інформаційних повідомлень
Виведення інформаційних повідомлень про успішне виконання та наявність помилок, якщо не активовано тихий режим.
* Перевіряє змінну QUIET. Якщо вона не дорівнює 1 (тобто тихий режим не активовано), виконуються дії:
* Виводить повідомлення про успішне створення вихідного файлу $result_file у стандартний потік виводу (stdout).
* Перевіряє, чи файл помилок ($error_file) не порожній (-s "$error_file"). Якщо він містить дані, виводить повідомлення про наявність помилок із вказівкою на файл $error_file.
* Використання змінної QUIET дозволяє керувати рівнем інформативності виведення, що зручно для автоматизованих сценаріїв.
* Перевірка розміру файлу помилок через -s уникає зайвих повідомлень, якщо помилок немає.
* Виведення в stdout для інформаційних повідомлень відповідає стандартам Unix.


243 if [[ "$QUIET" -ne 1 ]]; then
244  echo "Успішно створено файл: $result_file"
245  if [[ -s "$error_file" ]]; then
246    echo "Знайдено помилки при обробці, деталі у '$error_file'."
247  fi
248 fi
Фрагмент коду з основного сценарію, Додаток В.
3.2.18 Результати роботи
  

Рис.1 - запуск скрипта без паремтрів


  

Рис.2 - запуск скрипта з паремтрами


  

Рис.3 - виклик команди help


  

Рис.4 - виклик команди version


  

Рис.5 - готовий файл






































4 ВИСНОВКИ
Розроблений Bash-скрипт є ефективним і гнучким інструментом для обробки CSV-файлів із розкладом занять, забезпечуючи автоматизоване створення вихідного файлу у форматі, сумісному з Google Calendar. Він поєднує модульну структуру, надійну обробку помилок і підтримку кириличних символів завдяки використанню утиліт iconv, sed, awk, sort, grep та інтерактивного меню select. 
 Скрипт дозволяє гнучко вибирати CSV-файл і академічну групу (автоматично або через меню), перевіряє валідність даних (формати дати й часу), визначає типи занять (лекції, практики, лабораторні) за ключовими словами, враховує тривалість і парність лабораторних занять, а також форматує дані для коректного імпорту в Google Calendar (дата у форматі MM/DD/YYYY, час у 12-годинному форматі з AM/PM). Обробка помилок включає перевірку існування файлів, їх доступності, коректності даних і наявності занять для вибраної групи, із логуванням у файл помилок і виведенням повідомлень у stderr. Використання стандартних утиліт Linux забезпечує портативність, а інтерактивний інтерфейс і тихий режим роблять скрипт зручним для користувачів і автоматизованих сценаріїв. Загалом, скрипт є надійним рішенням для автоматизації обробки розкладів, що відповідає поставленим вимогам і враховує специфіку вхідних даних.






















ДОДАТОК А
Відеозапис
Відеозапис презентації результатів лабораторної роботи: 
https://youtu.be/y0ggHV6Ekmk
https://youtu.be/7DKIGYKZHHY
00:00 - допоміжні функції
00:30 - Обробка аргументів командного рядка
01:30 - Вибір CSV-файлу
02:45 - Вибір академічної групи
04:25  -  Ініціалізація вихідних файлів
05:25 -  Попередня обробка даних
07:30 -  Ініціалізація та функція trim
08:00 - Пошук поля з датою
08:30 -  Формування та фільтрація предмета
09:20 - Перевірка та форматування дати й часу
10:30 - Визначення типу заняття, форматування часу та збереження даних
11:30 - Сортування подій
13:00 -   Нумерація занять і виведення результату
15:00 - Перевірка успішності виконання awk
 15:25 - Виведення інформаційних повідомлень








ДОДАТОК Б
Графічні матеріали
  

Рис.1 - запуск скрипта без паремтрів


  

Рис.2 - запуск скрипта з паремтрами


  

Рис.3 - виклик команди help


  

Рис.4 - виклик команди version


  

Рис.5 - готовий файл
ДОДАТОК В 
Програмний код
Програмний код можна подивитись у GitHub репозиторії: https://github.com/NurePohorielovMaksym/smp-pzpi-23-3-pohorielov-maksym/blob/main/Lab1/smp-pzpi-23-3-pohorielov-maksym-lab1/smp-pzpi-23-3-pohorielov-maksym-lab1-code
 1  #!/bin/bash
 2  
 3  VERSION="1.0"
 4  QUIET=0
 5  
 6  show_help() {
 7    echo "Синтаксис:"
 8    echo "  task2 [--help | --version]"
 9    echo "  task2 [-q|--quiet] [академ_група] [файл.csv]"
10  }
11  
12  show_version() {
13    echo "task2 версія $VERSION"
14  }
15  
16  while [[ "$1" =~ ^- ]]; do
17    case "$1" in
18      --help) show_help; exit 0 ;;
19      --version) show_version; exit 0 ;;
20      -q|--quiet) QUIET=1; shift ;;
21      *) echo "Невідома опція: $1" >&2; exit 1 ;;
22    esac
23  done
24  
25  group_input="$1"
26  csv_path="$2"
27  
28  if [[ -z "$csv_path" ]]; then
29    files=($(ls TimeTable_??_??_20??.csv 2>/dev/null | sort))
30    if [[ ${#files[@]} -eq 0 ]]; then
31      echo "Не знайдено CSV файлів за шаблоном TimeTable_??_??_20??.csv" >&2
32      exit 1
33    fi
34    echo "Оберіть файл:"
35    PS3="Введіть номер файлу: "
36    select csv_path in "${files[@]}"; do
37      [[ -n "$csv_path" ]] && break
38      echo "Неправильний вибір, спробуйте ще." >&2
39    done
40  fi
41  
42  if [[ ! -f "$csv_path" || ! -r "$csv_path" ]]; then
43    echo "Файл '$csv_path' не існує або недоступний для читання." >&2
44    exit 1
45  fi
46  
47  available_groups=$(iconv -f windows-1251 -t utf-8 "$csv_path" | \
48    sed 's/\r\n/\n/g; s/\r/\n/g; s/^\xEF\xBB\xBF//' | \
49    sed 's/"//g' | \
50    awk -F',' 'NR > 1 && $1 ~ / - / { split($1, x, " - "); gsub(/^ +| +$/, "", x[1]); if (x[1] != "") print x[1] }' | sort -Vu)
51  
52  if [[ -z "$available_groups" ]]; then
53    echo "У файлі '$csv_path' не знайдено жодної академічної групи." >&2
54    exit 1
55  fi
56  
57  group_count=$(echo "$available_groups" | wc -l)
58  if [[ -z "$group_input" && $group_count -eq 1 ]]; then
59    selected_group="$available_groups"
60  elif [[ -z "$group_input" ]]; then
61    PS3="Оберіть групу: "
62    select selected_group in $available_groups; do
63      [[ -n "$selected_group" ]] && break
64      echo "Неправильний вибір, спробуйте ще." >&2
65    done
66  else
67    selected_group="$group_input"
68    if ! echo "$available_groups" | grep -Fx "$selected_group" >/dev/null; then
69      echo "Група '$selected_group' не знайдена у файлі '$csv_path'." >&2
70      echo "Доступні групи:" >&2
71      echo "$available_groups" >&2
72      exit 1
73    fi
74  fi
75  
76  date_part=$(basename "$csv_path" .csv | sed -n 's/TimeTable_\(.*\)/\1/p')
77  result_file="Google_TimeTable_${date_part}.csv"
78  error_file="Google_TimeTable_${date_part}_errors.txt"
79  
80  file_date=$(echo "$date_part" | sed 's/\([0-9]\{2\}\)_\([0-9]\{2\}\)_\([0-9]\{4\}\)/\2\/\1\/\3/')
81  default_date=${file_date:-"06/02/2025"}
82  
83  echo "\"Subject\",\"Start Date\",\"Start Time\",\"End Date\",\"End Time\",\"Description\"" > "$result_file"
84  > "$error_file" 
85  
86  iconv -f windows-1251 -t utf-8 "$csv_path" | \
87    sed 's/\r\n/\n/g; s/\r/\n/g; s/^\xEF\xBB\xBF//' | \
88    sed 's/"//g' | \
89  if [[ $? -ne 0 ]]; then
90    echo "Помилка під час обробки файлу '$csv_path'." >&2
91    echo "Деталі помилок записано у '$error_file'." >&2
92    exit 1
93  fi
94  
95  iconv -f windows-1251 -t utf-8 "$csv_path" | \
96    sed 's/\r\n/\n/g; s/\r/\n/g; s/^\xEF\xBB\xBF//' | \
97    sed 's/"//g' | \
98  awk -F ',' -v group="$selected_group" -v default_date="$default_date" -v OFS=',' '
99  function trim(s) {
100     sub(/^ +/, "", s)
101     sub(/ +$/, "", s)
102     return s
103   }
104   BEGIN {
105     PROCINFO["sorted_in"] = "@ind_str_asc"
106   }
107   NR > 1 {
108     date_field_idx = 0
109     for (i = 2; i <= NF; i++) {
110       if ($i ~ /^[0-3][0-9]\.[0-1][0-9]\.[0-9]{4}$/) {
111         date_field_idx = i
112         break
113       }
114     }
115     if (date_field_idx == 0) next
116  
117     subj = $1
118     for (j = 2; j < date_field_idx; j++) {
119       subj = subj "," $j
120     }
121     subj = trim(subj)
122  
123     if (subj !~ group " - ") next
124     split(subj, a, group " - ")
125     if (length(a) < 2) next
126     topic = trim(a[2])
127     if (topic == "") next
128  
129     if (NF < date_field_idx + 2) next
130  
131     date = $(date_field_idx)
132     time = $(date_field_idx + 1)
133  
134     if (date !~ /^[0-3][0-9]\.[0-1][0-9]\.[0-9]{4}$/ && time ~ /^[0-2][0-9]:[0-5][0-9]/) {
135       date = default_date
136     } else if (date !~ /^[0-3][0-9]\.[0-1][0-9]\.[0-9]{4}$/ || time !~ /^[0-2][0-9]:[0-5][0-9]/) {
137       next
138     }
139  
140     split(date, d, ".")
141     day = d[1] + 0
142     m = d[2] + 0
143     y = d[3] + 0
144     date_out = sprintf("%02d/%02d/%04d", m, day, y)
145  
146     topic_lc = tolower(topic)
147     if (topic_lc ~ /лаб|лб/) {
148       class_type = "lab"
149       duration_min = 180  
150     } else if (topic_lc ~ /пз|прпа/) {
151       class_type = "prac"
152       duration_min = 90   
153     } else if (topic_lc ~ /лек|лекц/) {
154       class_type = "lec"
155       duration_min = 90 
156     } else {
157       class_type = "lec"
158       duration_min = 90
159     }
160  
161     gsub(/;? *№[0-9]+/, "", topic)
162  
163     base_key = topic "|" class_type
164  
165     split(time, t, ":")
166     sh = t[1] + 0
167     sm = t[2]
168  
169     ampm = (sh >= 12) ? "PM" : "AM"
170     sh12 = (sh % 12 == 0) ? 12 : sh % 12
171     stime = sprintf("%02d:%02d %s", sh12, sm, ampm)
172  
173     start_minutes = sh * 60 + sm
174     end_minutes = start_minutes + duration_min
175     eh = int(end_minutes / 60)
176     em = end_minutes % 60
177  
178     eampm = (eh >= 12) ? "PM" : "AM"
179     eh12 = (eh % 12 == 0) ? 12 : eh % 12
180     etime = sprintf("%02d:%02d %s", eh12, em, eampm)
181  
182     sort_key = sprintf("%04d%02d%02d_%02d%02d_%d", y, m, day, sh, sm, NR)
183     result[sort_key] = base_key "|" "\"" topic "\",\"" date_out "\",\"" stime "\",\"" date_out "\",\"" etime "\",\"" subj "\""
184   }
185  
186   END {
187     n = 0
188     for (k in result) {
189       n++
190       keys[n] = k
191     }
192     asort(keys)
193  
194     for (i = 1; i <= n; i++) {
195       k = keys[i]
196       line = result[k]
197  
198       split(line, parts, "|")
199       base_key = parts[1]
200       class_type = parts[2]
201       data = substr(line, length(base_key) + length(class_type) + 3)
202  
203       if (!(base_key in count_map)) {
204         count_map[base_key] = 0
205         lab_pair_state[base_key] = 0
206       }
207  
208       if (class_type == "lab") {
209         if (lab_pair_state[base_key] == 1) {
210           lesson_num = count_map[base_key]
211           lab_pair_state[base_key] = 2
212         } else {
213           count_map[base_key]++
214           lesson_num = count_map[base_key]
215           lab_pair_state[base_key] = 1
216         }
217       } else {
218         count_map[base_key]++
219         lesson_num = count_map[base_key]
220         lab_pair_state[base_key] = 0
221       }
222  
223       match(data, /^"[^"]+"/)
224       topic_text = substr(data, RSTART + 1, RLENGTH - 2)
225       gsub(/;? *№[0-9]+/, "", topic_text)
226       new_topic = topic_text " №" lesson_num
227       updated_data = "\"" new_topic "\"" substr(data, RSTART + RLENGTH)
228       sub(/, *"[^"]+"$/, ",\"" new_topic "\"", updated_data)
229  
230       print updated_data
231     }
232   }
233  ' >> "$result_file"
234  
235  if [[ $? -ne 0 ]]; then
236    echo "Помилка під час обробки файлу '$csv_path'." >&2
237    echo "Деталі помилок записано у '$error_file'." >&2
238    exit 1
239  fi
240  
241  if [[ ! -s "$result_file" || $(wc -l < "$result_file") -eq 1 ]]; then
242    echo "Не знайдено занять для групи '$selected_group' у файлі '$csv_path'." >&2
243    exit 1
244  fi